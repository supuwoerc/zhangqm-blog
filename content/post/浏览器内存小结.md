---
title: "浏览器内存小结"
date: 2023-01-31T18:45:31+08:00
menu: "tech"
weight: 50
tags: ["前端"]
categories: ["技术"]
draft: false
typora-root-url: ../../static/
typora-copy-images-to: ../../static/
---
---

### JavaScript中的GC(Garbage collection)算法机制

* 引用计数

```javascript
function func(){
    const user1={}
    const user2={}
    user1.friend = user2   // user2引用数+1
    user2.friend = user1   // user1引用数+1,并且user1和user2为互相引用关系
}
func()
```

> 原理：当GC发现某一块内存中对象中的引用数为0时，GC会回收该块内存，实现垃圾回收。
> 缺陷：上述代码中存在循环引用的情况，那么在方法调用后`user1`和`user2`的引用数永远不会为0，GC机制不能将这两个变量回收掉。（一般出现在IE<8，Firefox3的浏览器中，IE6和IE7中有一部分对象是C++实现的COM（component object model），该种对象依赖于引用计数的策略来回收）

* 标记清除（目前主流的浏览器均实现了该方式的GC）

>原理：GC从`window`对象开始逐级对对象进行遍历，将可到达的节点对象结果和全部对象数据做对比，如果存在不被引用的对象空间，那么该空间会被回收。
>优点：解决了循环引用算法不能合理GC的问题，即使两个对象互相引用，只要这两个对象不被外部访问（可到达的节点），那么互相引用的对象会被一起回收。

![mark-sweep](/mark-sweep-5166632.gif)

### JavaScript常见的内存泄漏原因

* 非严格模式下的在`window`上缓存了变量

```javascript
function func(){
  bar = something //非严格模式下这样的语句会在window上挂载该变量
  or
  this.bar = something //在上下文为window时该语句等同于上面
}
func()
```

* 控制台上的输出

```javascript
function func(){
  //tips：一般来说可以借助webpack等构建工具来自动清除相类似的输出语句
  console.log(something) //当用户打开控制台时候，这个变量会占用内存（不打开控制台不会出现内存占用）
}
```

* 闭包

```javascript
function func(){
  const a = 0
  const b = 1
  function test(){
    a++ && b++
    return a + b
  }
  return test
}
// testFn能访问它的上下文中的全部数据（func的作用域），占用内存会比较大
const testFn = func() //此处的声明将会的到func执行后返回的test函数，该函数一直会被引用，内存空间将不会释放
testFn()   //调用函数
testFn = null //通过手动释放内存来避免引起的内存问题
```

* 定时器未及时清除

```javascript
function func(){
 const timer = setInterval(()=>{
    //do something
  },1000)
 clearInterval(timer) //清除定时器
}
func() 
```

* `listener`中的匿名函数和错误的解绑

```javascript
// 为按钮绑定点击事件
function bindEvent(){
  const btn = document.getElementById("id")
  // 绑定的是匿名函数 ！
  btn.addEventListener('click', function (event) {   
    // do something
  }, false);  
}
bindEvent() // 每次调用一次方法btn都会绑定上一个新的函数，因为匿名函数在内存中占用的内存不一样

//vue中借助lodash的防抖
mounted() {
    window.addEventListener('scroll', debounce(this.func, 200))
}
beforeDestroy() {
    window.removeEventListener('scroll', debounce(this.func, 200)) 
}
```

>  同一个元素节点注册了多个相同的EventListener，那么重复的实例会被抛弃。这么做不会让得EventListener被重复调用，也不需要用removeEventListener手动清除多余的EventListener，因为重复的都被自动抛弃了。而这条规则只是针对于命名函数。对于匿名函数，浏览器会将其看做不同的EventListener，所以只要将匿名的EventListener，命名一下就可以解决问题

```javascript
const callback =  function (event) {   
    // do something
}
// 为按钮绑定点击事件
function bindEvent(){
  const btn = document.getElementById("id")
  // 绑定的是匿名函数 ！
  btn.addEventListener('click', callback, false);  
}
bindEvent() // 此时callback始终是一个函数对象
```

### 使用开发者工具分析

 TODO

### 参考

* [排查JavaScript内存泄漏](https://zhuanlan.zhihu.com/p/322356761)
* [内存常见的 JavaScript 内存泄露分析](https://github.com/zhansingsong/js-leakage-patterns/blob/master/README.md)
* [JavaScript内存那点事](https://github.com/zhansingsong/js-leakage-patterns/blob/master/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B/JavaScript%E5%86%85%E5%AD%98%E9%82%A3%E7%82%B9%E4%BA%8B.md)
* [IE<8循环引用导致的内存泄漏](https://github.com/zhansingsong/js-leakage-patterns/blob/master/IE%3C8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/IE%3C8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.md)
* [内存泄漏之jQuery.cache](https://github.com/zhansingsong/js-leakage-patterns/blob/master/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8BjQuery.cache/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8BjQuery.cache.md)
* [内存泄漏之Listeners](https://github.com/zhansingsong/js-leakage-patterns/blob/master/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8BListeners/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8BListeners.md)
